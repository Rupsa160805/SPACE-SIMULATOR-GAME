<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>OBSTACLE DODGE GAME</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #00001a;
            font-family: 'Bangers', cursive;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1.5rem;
            z-index: 10;
        }
        .hud {
            display: flex;
            justify-content: space-between;
            width: 100%;
            align-items: flex-start;
        }
        .hud-item {
            font-size: 2.5rem;
            color: #f6e05e;
            text-shadow: 0 0 5px #f6e05e, 2px 2px 2px #000;
        }
        #emp-display {
            font-size: 2rem;
            color: #63b3ed;
             text-shadow: 0 0 5px #63b3ed, 2px 2px 2px #000;
        }
        .control-guide {
            position: absolute;
            right: 2rem;
            bottom: 2rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 1rem;
            z-index: 10;
            pointer-events: auto;
        }
        .control-guide div {
            font-size: 3rem;
            color: #f6e05e;
            text-shadow: 0 0 10px #f6e05e;
            cursor: pointer;
            background: rgba(0,0,0,0.3);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.2s;
            border: 2px solid #f6e05e;
        }
        #up-button { grid-column: 2; grid-row: 1; }
        #down-button { grid-column: 2; grid-row: 2; }
        #shield-button { grid-column: 1; grid-row: 2; font-size: 2.5rem; }

        .control-guide div:active {
            background: rgba(246, 224, 94, 0.5);
        }

        .modal-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 20;
            opacity: 1;
            transition: opacity 0.5s;
        }
        .modal-content {
            padding: 2rem;
            background: linear-gradient(to bottom, #4a5568, #1a202c);
            border-radius: 1.5rem;
            text-align: center;
            box-shadow: 0 0 20px rgba(0,0,0,0.6);
            border: 3px solid #718096;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .modal-content h2 {
            font-size: 3.5rem;
            margin-bottom: 1rem;
            color: #f6e05e;
            text-shadow: 2px 2px 5px #000;
        }
        .modal-content p {
            font-family: Arial, sans-serif;
            font-size: 1.1rem;
            margin-bottom: 1rem;
            color: #cbd5e0;
            line-height: 1.5;
        }
        .modal-content ul {
            font-family: Arial, sans-serif;
            color: #cbd5e0;
            list-style: none;
            padding: 0;
            margin-bottom: 1.5rem;
            text-align: left;
            display: inline-block;
        }
        .modal-content li { margin-bottom: 0.5rem; }
        .modal-content strong { color: #f6e05e; }
        .modal-content .control-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #718096;
        }
        .modal-content h3 {
            font-size: 1.5rem;
            color: #63b3ed;
            margin-bottom: 0.5rem;
        }

        .modal-content button {
            font-family: 'Bangers', cursive;
            font-size: 1.75rem;
            padding: 0.75rem 2rem;
            border-radius: 0.75rem;
            cursor: pointer;
            border: none;
            box-shadow: 0 4px #b7791f;
            transition: all 0.1s ease-in-out;
        }
        .modal-content button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #b7791f;
        }
        #difficulty-selection {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .difficulty-btn {
            font-size: 1.5rem !important;
            padding: 0.5rem 1.5rem !important;
        }
        .difficulty-btn[data-difficulty="easy"] { background-color: #48bb78; box-shadow: 0 4px #2f855a; color: #fff; }
        .difficulty-btn[data-difficulty="medium"] { background-color: #f6e05e; box-shadow: 0 4px #b7791f; color: #2d3748; }
        .difficulty-btn[data-difficulty="hard"] { background-color: #f56565; box-shadow: 0 4px #c53030; color: #fff; }
        .difficulty-btn:active { transform: translateY(2px); }
        .difficulty-btn[data-difficulty="easy"]:active { box-shadow: 0 2px #2f855a; }
        .difficulty-btn[data-difficulty="medium"]:active { box-shadow: 0 2px #b7791f; }
        .difficulty-btn[data-difficulty="hard"]:active { box-shadow: 0 2px #c53030; }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }
        .popup-text {
            font-size: 4rem;
            color: #fff;
            text-shadow: 0 0 10px #63b3ed, 3px 3px 3px #000;
            animation: fade-in-out 3s forwards;
        }
        .alert-text {
            color: #f56565;
            text-shadow: 0 0 10px #c53030, 3px 3px 3px #000;
        }
        @keyframes fade-in-out {
            0%, 100% { opacity: 0; transform: scale(0.8); }
            20%, 80% { opacity: 1; transform: scale(1); }
        }
        #minigame-prompt {
            font-size: 2rem;
            color: #f6e05e;
            text-shadow: 0 0 8px #000;
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            animation: blink 1.5s infinite;
        }
        @keyframes blink { 50% { opacity: 0.5; } }

        .fuel-container, .hyperdrive-container {
            width: 200px;
            height: 25px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #4a5a70;
            border-radius: 10px;
            padding: 3px;
            margin-top: 0.5rem;
        }
        #fuel-bar {
            height: 100%;
            background: linear-gradient(to right, #48bb78, #38a169);
            border-radius: 6px;
            transition: width 0.3s;
        }
        #hyperdrive-bar {
            height: 100%;
            background: linear-gradient(to right, #63b3ed, #4299e1);
            border-radius: 6px;
            transition: width 0.3s;
        }
        #constellation-prompt {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2.5rem;
            color: #a0deff;
            text-shadow: 0 0 10px #000;
            z-index: 30;
            text-align: center;
        }
        .flicker {
            animation: flicker-effect 0.15s infinite;
        }
        @keyframes flicker-effect {
              0%, 100% { opacity: 1; }
              50% { opacity: 0.3; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div class="ui-overlay">
        <div class="hud">
            <div class="flex flex-col">
                <div id="target-display" class="hud-item"></div>
                <div id="fuel-container" class="fuel-container">
                    <div id="fuel-bar" style="width: 100%;"></div>
                </div>
                 <div id="hyperdrive-container" class="hyperdrive-container hidden">
                    <div id="hyperdrive-bar" style="width: 0%;"></div>
                </div>
            </div>
            <div class="flex flex-col items-end">
                 <div id="distance-display" class="hud-item">DISTANCE: 0 km</div>
                 <div id="emp-display" class="hud-item">EMP: 0</div>
            </div>
        </div>
    </div>
    <div class="control-guide">
        <div id="up-button">‚ñ≤</div>
        <div id="down-button">‚ñº</div>
        <div id="shield-button">üõ°Ô∏è</div>
    </div>
    <div id="start-screen" class="modal-bg">
        <div class="modal-content">
            <h2>Cosmic Voyager</h2>
            <p>Your mission: Explore the cosmos, visit distant planets, and escape to the unknown! Use your fuel wisely to boost and power your shields against cosmic threats.</p>
            
            <div class="control-section">
                <h3>üöÄ Basic Flight</h3>
                <ul>
                    <li><strong>Arrow Keys/Buttons:</strong> Move Up/Down</li>
                    <li><strong>SHIFT Key:</strong> Boost Speed (uses fuel)</li>
                    <li><strong>'S' Key/üõ°Ô∏è Button:</strong> Activate Shield (drains fuel!)</li>
                    <li><strong>'E' Key:</strong> Fire EMP (destroys all obstacles)</li>
                </ul>
            </div>
            
            <div class="control-section">
                <h3>‚ú® Special Events & Mini-Games</h3>
                <ul>
                    <li><strong>Planet Orbit [SPACE]:</strong> To land or slingshot, tap SPACE when your ship passes through the glowing yellow zone on its orbit path.</li>
                    <li><strong>Black Hole Escape [Q Key]:</strong> You're being pulled in! Repeatedly mash the Q key to fire escape thrusters and fight against the gravity.</li>
                    <li><strong>Wormhole Travel [Keys 1-4]:</strong> A sequence of colored pads will light up. Memorize the pattern and repeat it using the number keys 1 through 4.</li>
                    <li><strong>Constellation Charting [Mouse/Touch]:</strong> A faint constellation will appear. Click and drag between the stars to connect them and trace the pattern before time runs out.</li>
                    <li><strong>Reflex Challenge [SPACE]:</strong> A blue ring will shrink towards a yellow target. Tap SPACE at the exact moment it aligns with the target for a reward.</li>
                </ul>
            </div>

            <p id="high-score-display" style="font-size: 1.5rem; color: #f6e05e;">High Score: 0 km</p>
            <div id="difficulty-selection">
                <button class="difficulty-btn" data-difficulty="easy">Easy</button>
                <button class="difficulty-btn" data-difficulty="medium">Medium</button>
                <button class="difficulty-btn" data-difficulty="hard">Hard</button>
            </div>
        </div>
    </div>
    <div id="game-over-screen" class="modal-bg hidden">
         <div class="modal-content">
            <h2 id="game-over-title">Mission Failed!</h2>
            <p id="final-distance">You traveled 0 km.</p>
            <p id="game-over-high-score" style="font-size: 1.25rem; color: #f6e05e;">High Score: 0 km</p>
            <button id="restart-button">Play Again</button>
        </div>
    </div>
     <div id="mission-screen" class="modal-bg hidden">
         <div class="modal-content">
            <h2 id="mission-title"></h2>
            <p id="mission-text"></p>
            <div id="mission-buttons" style="display: flex; justify-content: center; gap: 1rem; margin-top: 1rem;">
                <button id="exit-button" style="background-color: #a0aec0; box-shadow: 0 4px #4a5568; color: #1a202c;">Exit to Menu</button>
                <button id="continue-button">Continue Voyage</button>
            </div>
        </div>
    </div>
    <div id="popup-container" class="modal-bg hidden" style="background: transparent; pointer-events:none;">
        <div id="popup-text" class="popup-text"></div>
    </div>
    <div id="minigame-prompt" class="hidden"></div>
    <div id="constellation-prompt" class="hidden"></div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const missionScreen = document.getElementById('mission-screen');
        const gameOverTitle = document.getElementById('game-over-title');
        const restartButton = document.getElementById('restart-button');
        const continueButton = document.getElementById('continue-button');
        const exitButton = document.getElementById('exit-button');
        const distanceDisplay = document.getElementById('distance-display');
        const finalDistanceDisplay = document.getElementById('final-distance');
        const popupContainer = document.getElementById('popup-container');
        const popupText = document.getElementById('popup-text');
        const minigamePrompt = document.getElementById('minigame-prompt');
        const upButton = document.getElementById('up-button');
        const downButton = document.getElementById('down-button');
        const shieldButton = document.getElementById('shield-button');
        const fuelBar = document.getElementById('fuel-bar');
        const fuelContainer = document.getElementById('fuel-container');
        const hyperdriveContainer = document.getElementById('hyperdrive-container');
        const hyperdriveBar = document.getElementById('hyperdrive-bar');
        const targetDisplay = document.getElementById('target-display');
        const highScoreDisplay = document.getElementById('high-score-display');
        const gameOverHighScoreDisplay = document.getElementById('game-over-high-score');
        const empDisplay = document.getElementById('emp-display');
        const constellationPrompt = document.getElementById('constellation-prompt');


        // --- Logical solar system layout and state ---
        const SOLAR_SYSTEM_ORDER = ["Earth", "Moon", "Mars", "Asteroid Belt", "Jupiter", "Saturn", "Uranus", "Neptune", "Pluto"];
        const SOLAR_SYSTEM_TARGETS = ["Mars", "Jupiter", "Saturn", "Pluto"];
        const ANDROMEDA_PLANETS = ["Xylos", "Zarathos", "Kryll"];
        const TRIANGULUM_PLANETS = ["Spectra", "Gliese-1214b", "Helios-3"];
        const CENTAURUS_PLANETS = ["Proxima C", "Omega-7", "Stellara"];
        
        const GALAXY_ORDER = [
            { name: "Solar System", planets: SOLAR_SYSTEM_TARGETS, order: SOLAR_SYSTEM_ORDER, color: '#00001a', starColor: 'rgba(255, 255, 255,', obstacleTypes: ['asteroid'] },
            { name: "Andromeda", planets: ANDROMEDA_PLANETS, order: null, color: '#1a001a', starColor: 'rgba(200, 220, 255,', obstacleTypes: ['asteroid', 'alien'] },
            { name: "Triangulum", planets: TRIANGULUM_PLANETS, order: null, color: '#001a1a', starColor: 'rgba(200, 255, 220,', obstacleTypes: ['alien', 'crystal'] },
            { name: "Centaurus", planets: CENTAURUS_PLANETS, order: null, color: '#2a1a00', starColor: 'rgba(255, 220, 200,', obstacleTypes: ['crystal'] }
        ];
        let currentGalaxyIndex = 0;
        let flybyQueue = [];

        const CONSTELLATIONS = {
            'The Ship': { stars: [ {x:0.2, y:0.5}, {x:0.4, y:0.3}, {x:0.6, y:0.5}, {x:0.4, y:0.7} ], lines: [ {from:0, to:1}, {from:1, to:2}, {from:2, to:3}, {from:3, to:0} ] },
            'Big Dipper': { stars: [ {x:0.2, y:0.3}, {x:0.4, y:0.4}, {x:0.6, y:0.3}, {x:0.8, y:0.4}, {x:0.7, y:0.6}, {x:0.5, y:0.7} ], lines: [ {from:0, to:1}, {from:1, to:2}, {from:2, to:3}, {from:3, to:4}, {from:4, to:5} ] },
            'The Crown': { stars: [ {x:0.2, y:0.4}, {x:0.4, y:0.2}, {x:0.6, y:0.2}, {x:0.8, y:0.4}, {x:0.5, y:0.7} ], lines: [ {from:0, to:1}, {from:1, to:2}, {from:2, to:3}, {from:3, to:4}, {from:4, to:0} ] },
            'Orion\'s Belt': { stars: [ {x:0.3, y:0.6}, {x:0.5, y:0.5}, {x:0.7, y:0.4} ], lines: [ {from:0, to:1}, {from:1, to:2} ] },
            'The Arrow': { stars: [ {x:0.2, y:0.5}, {x:0.5, y:0.5}, {x:0.4, y:0.4}, {x:0.4, y:0.6} ], lines: [ {from:0, to:1}, {from:1, to:2}, {from:1, to:3} ] }
        };

        let missionQueue = [];
        let lastVisitedPlanet = null;
        let targetHasSpawned = false;
        let distanceSinceLastEncounter = 0;
        let blackHoleRotation = 0;
        let nebulaParticles = [];
        let phantoms = [];

        // Game State & Config
        let animationFrameId;
        let distance = 0;
        let targetPlanetName = "";
        let boosting = false, boostTimer = 0, shieldActive = false, shieldTimer = 0;
        let synths = {};
        let lastDifficulty = 'medium';
        let isAudioContextStarted = false;
        
        const planetImages = {};
        const imageSources = { "Sun": "https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/The_Sun_by_the_Atmospheric_Imaging_Assembly_of_NASA%27s_Solar_Dynamics_Observatory_-_20100819.jpg/512px-The_Sun_by_the_Atmospheric_Imaging_Assembly_of_NASA%27s_Solar_Dynamics_Observatory_-_20100819.jpg", "Mercury": "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/Mercury_in_true_color.jpg/512px-Mercury_in_true_color.jpg", "Venus": "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/Venus-real_color.jpg/512px-Venus-real_color.jpg", "Earth": "https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/The_Earth_seen_from_Apollo_17.jpg/512px-The_Earth_seen_from_Apollo_17.jpg", "Moon": "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e1/FullMoon2010.jpg/512px-FullMoon2010.jpg", "Mars": "https://upload.wikimedia.org/wikipedia/commons/thumb/0/02/OSIRIS_Mars_true_color.jpg/512px-OSIRIS_Mars_true_color.jpg", "Jupiter": "https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Jupiter_and_its_shrunken_Great_Red_Spot.jpg/512px-Jupiter_and_its_shrunken_Great_Red_Spot.jpg", "Saturn": "https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Saturn_during_Equinox.jpg/1024px-Saturn_during_Equinox.jpg", "Uranus": "https://upload.wikimedia.org/wikipedia/commons/thumb/3/3d/Uranus2.jpg/512px-Uranus2.jpg", "Neptune": "https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/Neptune.jpg/512px-Neptune.jpg", "Pluto": "https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Pluto_in_True_Color_-_High-Res.jpg/512px-Pluto_in_True_Color_-_High-Res.jpg", "Xylos": "https://i.imgur.com/gJ5Z2aY.png", "Zarathos": "https://i.imgur.com/GCR3lC3.png", "Kryll": "https://i.imgur.com/8Q9O2pW.png", "Spectra": "https://i.imgur.com/gJ5Z2aY.png", "Gliese-1214b": "https://i.imgur.com/GCR3lC3.png", "Helios-3": "https://i.imgur.com/8Q9O2pW.png", "Proxima C": "https://i.imgur.com/gJ5Z2aY.png", "Omega-7": "https://i.imgur.com/GCR3lC3.png", "Stellara": "https://i.imgur.com/8Q9O2pW.png"};

        const GameState = { MENU: 'MENU', FLYING: 'FLYING', EVENT: 'EVENT', ENTERING_ORBIT: 'ENTERING_ORBIT', ORBITING: 'ORBITING', GAMEOVER: 'GAMEOVER', MISSION_BRIEF: 'MISSION_BRIEF', CONSTELLATION_MINIGAME: 'CONSTELLATION_MINIGAME', WORMHOLE_MINIGAME: 'WORMHOLE_MINIGAME', HYPERDRIVE_ESCAPE: 'HYPERDRIVE_ESCAPE', TIMING_MINIGAME: 'TIMING_MINIGAME'};
        let gameState = GameState.MENU;
        let eventState = { active: false, type: null, duration: 0, hole: null, flickerInterval: null, gracePeriod: 0 };

        const DIFFICULTY_LEVELS = {
            easy:   { obstacleSpawnRate: 0.009, obstacleSpeedMultiplier: 1.0, fuelDrainRate: 0.10, shieldDrainRate: 0.4, collectibleSpawnRate: 0.012, slingshotWindow: 0.9, blackHolePull: 1.5, timingWindow: 15 },
            medium: { obstacleSpawnRate: 0.015, obstacleSpeedMultiplier: 1.2, fuelDrainRate: 0.20, shieldDrainRate: 0.7, collectibleSpawnRate: 0.008, slingshotWindow: 0.5, blackHolePull: 2.5, timingWindow: 10 },
            hard:   { obstacleSpawnRate: 0.025, obstacleSpeedMultiplier: 1.5, fuelDrainRate: 0.35, shieldDrainRate: 1.2, collectibleSpawnRate: 0.005, slingshotWindow: 0.3, blackHolePull: 4.0, timingWindow: 5 }
        };
        let gameDifficultySettings;

        const keys = { up: false, down: false, shift: false, shield: false, space: false, q: false };
        let minigameData = {};
        let constellationGame = {};
        let wormholeGame = {};
        let timingGame = {};
        let hyperdrive = { active: false, charge: 0, maxCharge: 100 };
        const player = { x: 100, y: 0, width: 40, height: 60, ay: 0.35, vy: 0, maxVy: 6, friction: 0.92, fuel: 100, maxFuel: 100, visible: true, empCharges: 1 };
        player.baseAy = player.ay;
        player.baseFriction = player.friction;
        let stars = [], midStars = [], farStars = [], planets = [], obstacles = [], collectibles = [], sceneryObjects = [];
        let empBlast = { active: false, radius: 0, maxRadius: 0 };
        let thrusterParticles = [];
        let thrusterParticlePool = [];
        
        const COLLECTIBLE_TYPES = {
            FUEL: { emoji: '‚õΩ', effect: (p) => { p.fuel = Math.min(p.maxFuel, p.fuel + 35); if(synths.collect) synths.collect.triggerAttackRelease("A5", "16n"); }},
            BOOST: { emoji: '‚ö°', effect: (p) => { boostTimer = 240; if(synths.collect) synths.collect.triggerAttackRelease("C6", "16n"); }},
            EMP: { emoji: 'üí•', effect: (p) => { p.empCharges++; if(synths.collect) synths.collect.triggerAttackRelease("E6", "16n"); }},
            SHIELD_BATTERY: { emoji: 'üîã', effect: (p) => { shieldTimer = 300; if(synths.collect) synths.collect.triggerAttackRelease("F#6", "16n"); }},
            EXOTIC_MATTER: { emoji: 'üí†', effect: () => {
                hyperdrive.charge = Math.min(hyperdrive.maxCharge, hyperdrive.charge + 15);
                if(synths.collect) synths.collect.triggerAttackRelease("B6", "16n");
            }},
            CHARGED_PARTICLE: { emoji: '‚ú®', effect: (p) => {
                p.empCharges++;
                if(synths.collect) synths.collect.triggerAttackRelease("G#6", "16n");
            }},
        };

        function setGameState(newState) { if (gameState !== newState) { gameState = newState; } }

        function gameLoop() {
            try {
                update();
                draw();
                if (gameState !== GameState.GAMEOVER && gameState !== GameState.MENU && gameState !== GameState.MISSION_BRIEF) {
                    animationFrameId = requestAnimationFrame(gameLoop);
                } else {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null; 
                }
            } catch (error) {
                console.error("Error in game loop:", error);
                endGame("A critical error occurred!");
            }
        }
        
        function update() {
            try {
                switch(gameState) {
                    case GameState.FLYING: case GameState.EVENT: case GameState.HYPERDRIVE_ESCAPE: updateFlying(); break;
                    case GameState.ENTERING_ORBIT: updateEnteringOrbit(); break;
                    case GameState.ORBITING: updateOrbiting(); break;
                    case GameState.CONSTELLATION_MINIGAME: updateConstellationGame(); break;
                    case GameState.WORMHOLE_MINIGAME: updateWormholeGame(); break;
                    case GameState.TIMING_MINIGAME: updateTimingGame(); break;
                }
            } catch (e) {
                console.error("Error in update function for state:", gameState, e);
                setGameState(GameState.FLYING); // Attempt to recover
            }
        }

        function draw() {
            switch(gameState) {
                case GameState.FLYING: case GameState.EVENT: case GameState.HYPERDRIVE_ESCAPE: drawFlying(); break;
                case GameState.ENTERING_ORBIT: drawEnteringOrbit(); break;
                case GameState.ORBITING: drawOrbiting(); break;
                case GameState.CONSTELLATION_MINIGAME: drawConstellationGame(); break;
                case GameState.WORMHOLE_MINIGAME: drawWormholeGame(); break;
                case GameState.TIMING_MINIGAME: drawTimingGame(); break;
            }
        }

        function startGame(difficulty) {
            if(animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            lastDifficulty = difficulty; 
            gameDifficultySettings = DIFFICULTY_LEVELS[difficulty];
            currentGalaxyIndex = 0;
            let galaxyInfo = GALAXY_ORDER[currentGalaxyIndex];
            let missionTargets = [...galaxyInfo.planets];
            for (let i = missionTargets.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [missionTargets[i], missionTargets[j]] = [missionTargets[j], missionTargets[i]]; }
            missionQueue = missionTargets;
            lastVisitedPlanet = "Earth";
            hyperdrive.active = false;
            hyperdriveContainer.classList.add('hidden');
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            init();
            startMusic();
            startNextMissionLeg();
        }
        
        function startNextMissionLeg() {
            let galaxyInfo = GALAXY_ORDER[currentGalaxyIndex];
            if (missionQueue.length === 0) {
                if (currentGalaxyIndex >= GALAXY_ORDER.length - 1) { 
                    presentFinalMissionBrief(); 
                } else { 
                    triggerIntergalacticWormhole(currentGalaxyIndex + 1); 
                }
                return;
            }
            resetForNextLeg();
            setGameState(GameState.FLYING);
            targetPlanetName = missionQueue.shift();
            targetDisplay.textContent = `TARGET: ${targetPlanetName} (${galaxyInfo.name})`;
            setupMissionPath();
            if (!animationFrameId) { gameLoop(); }
        }

        function presentFinalMissionBrief() {
            setGameState(GameState.MISSION_BRIEF);
            player.visible = false;
            stopMusic();
            if(synths.victory) synths.victory.triggerAttackRelease("G5", "1n");
            document.getElementById('mission-title').textContent = `Grand Tour Complete!`;
            document.getElementById('mission-text').textContent = "You've visited every major body in the known galaxies. Your final mission is to escape this universe entirely. Charge your hyperdrive and jump to the unknown!";
            document.getElementById('continue-button').textContent = "Begin Final Escape";
            missionScreen.classList.remove('hidden');
        }

        function setupMissionPath() {
            flybyQueue = [];
            const galaxyInfo = GALAXY_ORDER[currentGalaxyIndex];
            if (galaxyInfo.order) {
                const lastIndex = galaxyInfo.order.indexOf(lastVisitedPlanet);
                const targetIndex = galaxyInfo.order.indexOf(targetPlanetName);
                if (lastIndex !== -1 && targetIndex !== -1 && lastIndex < targetIndex) {
                    flybyQueue = galaxyInfo.order.slice(lastIndex + 1, targetIndex);
                }
            }

            const eventChance = 0.90; 

            if (flybyQueue.includes("Asteroid Belt") && Math.random() < 0.4) {
                setTimeout(() => triggerEvent('ASTEROID_BELT', 1500), 2000);
            } else {
                const roll = Math.random();
                if (roll < eventChance * 0.3) {
                    setTimeout(() => triggerEvent('BLACK_HOLE', 1000), 2000);
                } else if (roll < eventChance * 0.6) {
                    setTimeout(() => triggerEvent('NEBULA', 1500), 2500);
                } else if (roll < eventChance * 0.8) {
                     setTimeout(() => triggerEvent('WORMHOLE', 'skip'), 3000);
                } else if (roll < eventChance) {
                    setTimeout(() => triggerTimingGame(), 1500);
                }
            }
            flybyQueue = flybyQueue.filter(p => p !== "Asteroid Belt");
        }

        function init() { distance = 0; createStars(200, 0.3, 0.8, farStars); createStars(100, 0.6, 1.2, midStars); createStars(50, 1.2, 1.6, stars); }
        
        function resetForNextLeg(){
            player.x = 100; player.y = canvas.height / 2 - player.height / 2;
            player.vy = 0; player.fuel = 100; player.visible = true; 
            if (lastDifficulty === 'easy') player.empCharges = 3; else if (lastDifficulty === 'medium') player.empCharges = 2; else player.empCharges = 1;
            planets = []; obstacles = []; phantoms = []; collectibles = []; sceneryObjects = []; thrusterParticles = [];
            boostTimer = 0; shieldTimer = 0; shieldActive = false; eventState.active = false; targetHasSpawned = false;
            distanceSinceLastEncounter = 0;
        }

        function updateFlying() {
            if (eventState.gracePeriod > 0) eventState.gracePeriod--;

            if (gameState === GameState.HYPERDRIVE_ESCAPE) {
                hyperdriveBar.style.width = `${hyperdrive.charge}%`;
                if (hyperdrive.charge >= hyperdrive.maxCharge && minigamePrompt.classList.contains('hidden')) {
                    minigamePrompt.textContent = "HYPERDRIVE CHARGED! PRESS [SPACE]!";
                    minigamePrompt.classList.remove('hidden');
                }
            }

            if (eventState.active && eventState.type === 'NEBULA') {
                player.ay = player.baseAy * 0.5; player.friction = player.baseFriction * 1.05; if (player.fuel > 0) player.fuel -= 0.05;
            } else {
                player.ay = player.baseAy; player.friction = player.baseFriction;
            }

            if (gameState === GameState.FLYING && !eventState.active && planets.length < 1 && Math.random() < 0.0005) {
                triggerConstellationGame();
                return;
            }
            
            if (eventState.active && eventState.type === 'BLACK_HOLE') {
                if (!eventState.hole) {
                    succeedBlackHoleEvent(); // Failsafe
                    return;
                }
                blackHoleRotation += 0.01;
                
                if (eventState.gracePeriod <= 0) {
                    player.x -= gameDifficultySettings.blackHolePull;
                }
                
                const allObjects = [...obstacles, ...collectibles, ...sceneryObjects];
                for (const obj of allObjects) {
                    const dX = eventState.hole.x - obj.x; const dY = eventState.hole.y - obj.y;
                    const distSq = dX * dX + dY * dY;
                    if (distSq > 10000) { 
                        const pullForce = 15000 / distSq; obj.x += dX * pullForce; obj.y += dY * pullForce;
                    }
                }

                if (keys.q) { player.x += 8; } 

                if (eventState.gracePeriod <= 0 && player.x < eventState.hole.x + eventState.hole.radius * 0.6) { 
                    endGame("Consumed by a black hole!"); 
                    return; 
                }
                if (player.x > canvas.width + 50) {
                    succeedBlackHoleEvent();
                    return;
                }
            } else {
                 player.x = 100;
            }
            
            if (keys.up) player.vy -= player.ay; else if (keys.down) player.vy += player.ay;
            player.vy *= player.friction;
            if (Math.abs(player.vy) > player.maxVy) player.vy = Math.sign(player.vy) * player.maxVy;
            player.y += player.vy;
            if (player.y < 0) { player.y = 0; player.vy = 0; }
            if (player.y + player.height > canvas.height) { player.y = canvas.height - player.height; player.vy = 0; }

            let isCurrentlyBoosting = false;
            if (boostTimer > 0) { isCurrentlyBoosting = true; boostTimer--; } 
            else if (keys.shift && player.fuel > 0 && !(eventState.active && eventState.type === 'BLACK_HOLE')) { isCurrentlyBoosting = true; player.fuel -= gameDifficultySettings.fuelDrainRate; }
            boosting = isCurrentlyBoosting;
            
            shieldActive = (keys.shield && player.fuel > 0) || shieldTimer > 0;
            if (shieldActive) {
                if (shieldTimer > 0) {
                    shieldTimer--;
                } else {
                    player.fuel -= gameDifficultySettings.shieldDrainRate;
                    if(player.fuel <= 0) { player.fuel = 0; shieldActive = false; keys.shield = false; }
                }
            }
            fuelBar.style.width = `${player.fuel}%`;

            updateStars(farStars); updateStars(midStars); updateStars(stars);
            updatePlanets(); updateObstacles(); updateCollectibles(); updatePhantoms(); updateThrusters(); updateSceneryObjects();
            detectCollisions();
            
            const speedIncrement = boosting ? 4 : 1;
            if (!(eventState.active && eventState.type === 'BLACK_HOLE')) {
                distance += speedIncrement;
                distanceSinceLastEncounter += speedIncrement;
            }

            distanceDisplay.textContent = `DISTANCE: ${Math.floor(distance)} km`;
            empDisplay.textContent = `EMP: ${player.empCharges}`;
            
            if(eventState.active){
                eventState.duration -= 1;
                if(eventState.duration <= 0){
                    const lastEventType = eventState.type;
                    eventState.active = false; 
                    eventState.type = null;
                    boosting = false; 
                    player.x = 100;
                    if(lastEventType === 'NEBULA' || lastEventType === 'ASTEROID_BELT') {
                        if(eventState.flickerInterval) clearInterval(eventState.flickerInterval);
                        eventState.flickerInterval = null;
                        document.querySelectorAll('.flicker').forEach(el => el.classList.remove('flicker'));
                        phantoms = [];
                        showPopup("Anomaly Cleared!", false);
                    }
                    if(lastEventType === 'BLACK_HOLE') {
                        endGame("Failed to escape the anomaly!");
                    }
                }
            }
        }

        function drawFlying() {
            ctx.save();
            const isBlackHole = eventState.active && eventState.type === 'BLACK_HOLE';
            const shakeMagnitude = isBlackHole ? Math.min(15, 300 / player.x) : (eventState.active && (eventState.type === 'NEBULA' || eventState.type === 'ASTEROID_BELT') ? 2 : 0);
            if (shakeMagnitude > 0) { ctx.translate((Math.random() - 0.5) * shakeMagnitude, (Math.random() - 0.5) * shakeMagnitude); }

            clear();
            drawStars(farStars);
            if (isBlackHole) drawBlackHole();
            if (eventState.active && eventState.type === 'NEBULA') drawNebula();
            drawStars(midStars); 
            drawPlanets(); 
            drawCollectibles(); drawPhantoms(); drawObstacles(); drawSceneryObjects();
            drawPlayer(); 
            drawThrusters(); drawShield();
            drawStars(stars);
            drawEMPBlast();
            ctx.restore();
        }

        function drawNebula() { nebulaParticles.forEach(p => { p.x -= p.speed; if (p.x + p.radius < 0) { p.x = canvas.width + p.radius; } ctx.globalAlpha = 0.5; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1.0; }); }
        
        function succeedBlackHoleEvent() {
            showPopup("Successful Escape!", false);
            eventState.active = false;
            eventState.type = null;
            eventState.hole = null;
            player.x = 100;
        }

        function drawBlackHole() {
            if (!eventState.active || eventState.type !== 'BLACK_HOLE' || !eventState.hole) return;
            const hole = eventState.hole; const centerX = hole.x; const centerY = hole.y;
            ctx.save();
            ctx.translate(centerX, centerY); ctx.rotate(blackHoleRotation);
            const diskGradient = ctx.createRadialGradient(0, 0, hole.radius * 0.5, 0, 0, hole.radius * 1.5);
            diskGradient.addColorStop(0, 'rgba(0, 0, 0, 0)'); diskGradient.addColorStop(0.6, '#4a00e0'); diskGradient.addColorStop(0.8, '#8e2de2'); diskGradient.addColorStop(1, 'rgba(100, 200, 255, 0.5)');
            ctx.fillStyle = diskGradient; ctx.globalAlpha = 0.7; ctx.fillRect(-hole.radius * 2, -hole.radius * 2, hole.radius * 4, hole.radius * 4);
            ctx.globalAlpha = 1.0; ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(0, 0, hole.radius * 0.7, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }

        function getPlanetRadius(planetName) { if (planetName === 'Sun') return 200; if (planetName === 'Jupiter') return 180; if (planetName === 'Saturn') return 160; return Math.random() * 80 + 60; }

        function updatePlanets() {
            if (gameState === GameState.HYPERDRIVE_ESCAPE) return;
            const planetSpawnDistance = 3000;
            let planetToSpawn = null; let isFlyby = false;
            if (distanceSinceLastEncounter > planetSpawnDistance && planets.length < 1 && !eventState.active) {
                if (flybyQueue.length > 0) { planetToSpawn = flybyQueue.shift(); isFlyby = true; } 
                else if (!targetHasSpawned) { planetToSpawn = targetPlanetName; isFlyby = false; targetHasSpawned = true; }
            }
            if (planetToSpawn) {
                distanceSinceLastEncounter = 0;
                const radius = getPlanetRadius(planetToSpawn);
                planets.push({ x: canvas.width + radius * 2, y: Math.random() * canvas.height, radius: radius, speed: Math.random() * 0.3 + 0.15, name: planetToSpawn, isFlyby: isFlyby });
            }
            planets.forEach((planet, index) => {
                planet.x -= (boosting ? (planet.speed || 1) * 4 : (planet.speed || 1));
                if (planet.x + (planet.radius * 2) < 0) { planets.splice(index, 1); }
                if (!planet.approached && planet.x < canvas.width * 1.5) { planet.approached = true; showPopup(`Approaching ${planet.name}${planet.isFlyby ? ' (Fly-by)' : ''}...`, false); }
                if (planet.approached && !planet.handled && planet.x < canvas.width / 2 + 200 && (gameState === GameState.FLYING || gameState === GameState.EVENT)) { planet.handled = true; triggerMinigame(planet); }
            });
        }
        
        function updateObstacles() {
            let spawnRate = gameDifficultySettings.obstacleSpawnRate;
            if (distance < 3000) { spawnRate *= 0.1; }
            if (gameState === GameState.HYPERDRIVE_ESCAPE) spawnRate *= 5;
            if (eventState.active && eventState.type === 'ASTEROID_BELT') spawnRate *= 5;
            if (eventState.active && eventState.type === 'BLACK_HOLE') return;

            if (Math.random() < spawnRate) {
                const galaxyObstacles = GALAXY_ORDER[currentGalaxyIndex].obstacleTypes;
                const type = galaxyObstacles[Math.floor(Math.random() * galaxyObstacles.length)];
                obstacles.push({ size: Math.random() * 30 + 20, speed: (Math.random() * 2 + 1.5) * gameDifficultySettings.obstacleSpeedMultiplier, rotation: 0, rotationSpeed: type === 'crystal' ? 0 : (Math.random() - 0.5) * 0.05, shape: createAsteroidShape(1), type: type, x: canvas.width, y: Math.random() * canvas.height });
            }
            
            obstacles = obstacles.filter(obstacle => {
                obstacle.x -= (boosting ? obstacle.speed * 4 : obstacle.speed);
                obstacle.rotation += obstacle.rotationSpeed;
                return obstacle.x + obstacle.size > -50;
            });
        }

        function updateSceneryObjects() {
            sceneryObjects = sceneryObjects.filter(obj => {
                // Let black hole logic handle movement if active
                if (!eventState.active || eventState.type !== 'BLACK_HOLE') {
                    obj.x -= (boosting ? obj.speed * 4 : obj.speed);
                }
                return obj.x + 50 > 0;
            });
        }

        function drawSceneryObjects() {
            sceneryObjects.forEach(obj => {
                ctx.font = `${obj.size}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.save();
                ctx.translate(obj.x, obj.y);
                ctx.rotate(obj.rotation);
                ctx.fillText(obj.emoji, 0, 0);
                ctx.restore();
            });
        }

        function updatePhantoms() { if (eventState.active && eventState.type === 'NEBULA' && Math.random() < 0.03) { const size = Math.random() * 40 + 25; phantoms.push({ x: canvas.width + size, y: Math.random() * (canvas.height - size), size: size, speed: Math.random() * 2 + 1, rotation: 0, rotationSpeed: (Math.random() - 0.5) * 0.02, shape: createAsteroidShape(size) }); } const livePhantoms = []; for(const p of phantoms) { p.x -= (boosting ? p.speed * 4 : p.speed); p.rotation += p.rotationSpeed; if (p.x + p.size > 0) { livePhantoms.push(p); } } phantoms = livePhantoms; }
        
        function updateCollectibles() {
            if (eventState.active && eventState.type === 'BLACK_HOLE') return;

            let spawnRate = gameDifficultySettings.collectibleSpawnRate;
            let collectiblePool = ["FUEL", "BOOST", "EMP"];
            if (currentGalaxyIndex > 0) { collectiblePool.push("SHIELD_BATTERY"); }
            
            if (gameState === GameState.HYPERDRIVE_ESCAPE) { 
                if (Math.random() < 0.02) { 
                    collectibles.push({ x: canvas.width + 30, y: Math.random() * (canvas.height - 30), size: 40, type: COLLECTIBLE_TYPES.EXOTIC_MATTER, speed: Math.random() * 3 + 3 }); 
                } 
            } else if (eventState.active && eventState.type === 'NEBULA') { 
                if (Math.random() < 0.02) { 
                    collectibles.push({ x: canvas.width + 30, y: Math.random() * (canvas.height - 30), size: 30, type: COLLECTIBLE_TYPES.CHARGED_PARTICLE, speed: Math.random() * 2 + 2 }); 
                } 
            } else { 
                if (Math.random() < spawnRate) { 
                    const typeName = collectiblePool[Math.floor(Math.random() * collectiblePool.length)]; 
                    collectibles.push({ x: canvas.width + 30, y: Math.random() * (canvas.height - 30), size: 30, type: COLLECTIBLE_TYPES[typeName], speed: Math.random() * 2 + 2 }); 
                } 
            }
            
            collectibles = collectibles.filter(c => {
                 c.x -= (boosting ? c.speed * 4 : c.speed); 
                 return c.x + c.size > -50;
            });
        }
        
        function clear() { ctx.fillStyle = GALAXY_ORDER[currentGalaxyIndex].color; ctx.fillRect(0, 0, canvas.width, canvas.height); }
        function createStars(count, speed, radius, array) { array.length = 0; for (let i = 0; i < count; i++) { array.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * radius, baseSpeed: Math.random() * speed + (speed / 2), alpha: Math.random() * 0.5 + 0.5 }); } }
        function drawStars(array) { const color = GALAXY_ORDER[currentGalaxyIndex].starColor; array.forEach(star => { ctx.beginPath(); ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2); ctx.fillStyle = `${color} ${star.alpha})`; ctx.fill(); }); }
        
        function drawPlanets() { planets.forEach(planet => { const img = planetImages[planet.name]; if (img && img.complete) { ctx.save(); let drawWidth = planet.radius * 2; let drawHeight = planet.radius * 2; if (planet.name === "Saturn") { drawWidth *= 1.8; }  else if (planet.name !== "Sun") { ctx.beginPath(); ctx.arc(planet.x, planet.y, planet.radius, 0, Math.PI * 2, true); ctx.clip(); } ctx.drawImage(img, planet.x - drawWidth / 2, planet.y - drawHeight / 2, drawWidth, drawHeight); ctx.restore(); } else { ctx.fillStyle = '#9F7AEA'; ctx.beginPath(); ctx.arc(planet.x, planet.y, planet.radius, 0, Math.PI * 2); ctx.fill(); } }); }
        function drawObstacles() { obstacles.forEach(obstacle => { ctx.save(); ctx.translate(obstacle.x, obstacle.y); ctx.rotate(obstacle.rotation); if (eventState.active && eventState.type === 'NEBULA') { ctx.globalAlpha = 0.4; } 
            if (obstacle.type === 'alien') { ctx.font = `${obstacle.size * 1.5}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('üëæ', 0, 0); }
            else if(obstacle.type === 'crystal') {
                ctx.fillStyle = '#a0deff'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5; ctx.beginPath();
                const points = obstacle.shape.map(p => ({ x: p.x * obstacle.size * 1.2, y: p.y * obstacle.size * 1.2 })); // Make crystals sharper
                ctx.moveTo(points[0].x, points[0].y);
                for(let i = 1; i < points.length; i++) { ctx.lineTo(points[i].x, points[i].y); }
                ctx.closePath(); ctx.fill(); ctx.stroke();
            } 
            else { const points = obstacle.shape.map(p => ({ x: p.x * obstacle.size, y: p.y * obstacle.size })); ctx.fillStyle = '#8B4513'; ctx.strokeStyle = '#A0522D'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); for(let i = 1; i < points.length; i++) { ctx.lineTo(points[i].x, points[i].y); } ctx.closePath(); ctx.fill(); ctx.stroke(); } 
            ctx.restore(); }); }
        function drawPhantoms() { phantoms.forEach(p => { ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rotation); ctx.globalAlpha = 0.2; ctx.fillStyle = '#63b3ed'; ctx.strokeStyle = '#4299e1'; ctx.lineWidth = 2; ctx.beginPath(); const points = p.shape.map(point => ({x: point.x * p.size, y: point.y * p.size})); ctx.moveTo(points[0].x, points[0].y); for(let i = 1; i < points.length; i++) { ctx.lineTo(points[i].x, points[i].y); } ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore(); }); }
        function createAsteroidShape(radius) { const points = []; const numPoints = Math.floor(Math.random() * 5) + 7; for(let i = 0; i < numPoints; i++) { const angle = (i / numPoints) * Math.PI * 2; const dist = radius * (0.8 + Math.random() * 0.4); points.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist }); } return points; }
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }

        function drawPlayer() { if (!player.visible) return; ctx.save(); ctx.translate(player.x + player.width / 2, player.y + player.height / 2); ctx.rotate(player.vy * 0.05); ctx.font = `${player.height}px sans-serif`; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText('üöÄ', 0, 0); ctx.restore(); }
        
        function updateStars(starArray) { starArray.forEach(star => { if (eventState.active && eventState.type === 'BLACK_HOLE' && eventState.hole) { const dx = eventState.hole.x - star.x; const dy = eventState.hole.y - star.y; const dist = Math.hypot(dx, dy); if (dist > 1) { star.x += (dx / dist) * 2.5; star.y += (dy / dist) * 2.5; } } else { let speed = (boosting ? star.baseSpeed * 8 : star.baseSpeed); if (gameState === GameState.HYPERDRIVE_ESCAPE) speed *= 2; star.x -= speed; } if (star.x < -10) { star.x = canvas.width; star.y = Math.random() * canvas.height; } }); }
        
        function drawCollectibles() { collectibles.forEach(c => { ctx.font = `${c.size}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(c.type.emoji, c.x, c.y); }); }
        
        function updateThrusters() {
            const isBlackHoleEvent = eventState.active && eventState.type === 'BLACK_HOLE';
            if ((keys.up || keys.down || boosting || (isBlackHoleEvent && keys.q))) {
                const count = (boosting || keys.q) ? 5 : 2;
                for (let i = 0; i < count; i++) {
                    let p = thrusterParticlePool.pop() || {};
                    p.y = player.y + player.height / 2 + (Math.random() - 0.5) * 10;
                    p.life = 20;

                    if (isBlackHoleEvent && keys.q) {
                        p.x = player.x + player.width; p.size = Math.random() * 6 + 3; p.vx = (Math.random() * 8 + 8);
                        p.color = ['#90ee90', '#63b3ed', '#ffffff'][Math.floor(Math.random() * 3)];
                    } else {
                        p.x = player.x; p.size = Math.random() * (boosting ? 5 : 3) + 1; p.vx = -(Math.random() * 5 + 5);
                        p.color = ['#ffcc00', '#ffaa00', '#ff6600'][Math.floor(Math.random() * 3)];
                    }
                    thrusterParticles.push(p);
                }
            }
            
            let liveParticles = [];
            for (const p of thrusterParticles) {
                p.life--;
                if (p.life > 0) { p.x += p.vx; liveParticles.push(p); } 
                else { thrusterParticlePool.push(p); }
            }
            thrusterParticles = liveParticles;
        }
        function drawThrusters() {
            ctx.globalAlpha = 0.7;
            thrusterParticles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * (p.life / 20), 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;
        }

        function drawShield() {
            if (player.visible && shieldActive) {
                const shieldColor = shieldTimer > 0 ? `rgba(255, 215, 0, ${0.5 + Math.random() * 0.3})` : `rgba(100, 200, 255, ${0.5 + Math.random() * 0.3})`;
                const fillColor = shieldTimer > 0 ? `rgba(255, 215, 0, ${0.1 + Math.random() * 0.1})` : `rgba(100, 200, 255, ${0.1 + Math.random() * 0.1})`;
                ctx.strokeStyle = shieldColor; ctx.fillStyle = fillColor; ctx.lineWidth = 3; 
                ctx.beginPath(); ctx.arc(player.x + player.width / 2, player.y + player.height / 2, player.height, 0, Math.PI * 2); ctx.stroke(); ctx.fill();
            }
        }
        function drawEMPBlast() { if(empBlast.active) { empBlast.radius += 40; ctx.strokeStyle = `rgba(100, 200, 255, ${1 - empBlast.radius / empBlast.maxRadius})`; ctx.lineWidth = 10; ctx.beginPath(); ctx.arc(player.x + player.width/2, player.y + player.height/2, empBlast.radius, 0, Math.PI*2); ctx.stroke(); if(empBlast.radius >= empBlast.maxRadius) empBlast.active = false; } }

        // --- Collision and Game Logic ---
        function detectCollisions() {
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                const playerRect = { x: player.x, y: player.y, width: player.width, height: player.height };
                const obstacleRect = { x: obstacle.x - obstacle.size / 2, y: obstacle.y - obstacle.size / 2, width: obstacle.size, height: obstacle.size };
                if (player.visible && playerRect.x < obstacleRect.x + obstacleRect.width && playerRect.x + playerRect.width > obstacleRect.x && playerRect.y < obstacleRect.y + obstacleRect.height && playerRect.y + playerRect.height > obstacleRect.y) {
                    if (shieldActive) {
                        obstacles.splice(i, 1);
                        if (synths.shot) synths.shot.triggerAttackRelease("A3", "8n");
                    } else {
                        endGame("You were struck by a cosmic hazard!");
                        return;
                    }
                }
            }
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const c = collectibles[i];
                if (player.visible && player.x < c.x + c.size && player.x + player.width > c.x && player.y < c.y + c.size && player.y + player.height > c.y) {
                    c.type.effect(player);
                    collectibles.splice(i, 1);
                }
            }
        }

        function triggerEMP() {
            if (player.empCharges > 0) {
                player.empCharges--;
                obstacles = [];
                empBlast = { active: true, radius: 0, maxRadius: canvas.width };
                if (synths.emp) synths.emp.triggerAttackRelease("8n");
            }
        }

        // --- Mini-Game: Orbit ---
        function triggerMinigame(planet) {
            setGameState(GameState.ENTERING_ORBIT);
            const isTarget = !planet.isFlyby;
            const orbitCount = isTarget ? (Math.random() > 0.5 ? 2 : 1) : 1;
            minigamePrompt.textContent = isTarget ? `TARGET: ${planet.name}! TAP [SPACE] AT APOGEE TO LAND!` : `SLINGSHOT AROUND ${planet.name}! TAP [SPACE] AT PERIGEE!`;
            minigamePrompt.classList.remove('hidden');
            const radius = planet.radius;
            let orbits = [];
            const orbitScale = radius > 150 ? 1.8 : 2.5;
            for (let i = 0; i < orbitCount; i++) { orbits.push(radius * (orbitScale - (0.5 * i))); }
            minigameData = {
                planet, orbits, currentOrbit: 0, isTargetPlanet: isTarget, originalRadius: radius,
                angle: Math.atan2(player.y - planet.y, player.x - planet.x), speed: 0.015,
                escapeWindow: gameDifficultySettings.slingshotWindow, entryProgress: 0,
                entryStartX: player.x, entryStartY: player.y,
                entryTargetX: planet.x + Math.cos(Math.PI) * orbits[0],
                entryTargetY: planet.y + Math.sin(Math.PI) * orbits[0],
            };
        }
        
        function updateEnteringOrbit() {
            if (!minigameData || !minigameData.planet) return;
            minigameData.entryProgress += 0.008;
            minigameData.planet.radius = lerp(minigameData.originalRadius, minigameData.originalRadius * 1.3, minigameData.entryProgress);
            player.x = lerp(minigameData.entryStartX, minigameData.entryTargetX, minigameData.entryProgress);
            player.y = lerp(minigameData.entryStartY, minigameData.entryTargetY, minigameData.entryProgress);
            if (minigameData.entryProgress >= 1) {
                const orbitScale = minigameData.originalRadius > 150 ? 1.8 : 2.5;
                for(let i=0; i < minigameData.orbits.length; i++) {
                    minigameData.orbits[i] = minigameData.planet.radius * (orbitScale - (0.5 * i));
                }
                setGameState(GameState.ORBITING);
            }
        }
        
        function drawEnteringOrbit() {
            clear();
            updateStars(farStars); updateStars(midStars); updateStars(stars);
            drawStars(farStars); drawStars(midStars); drawStars(stars);
            drawPlanets(); drawPlayer();
        }

        function updateOrbiting() {
            if (!minigameData || !minigameData.planet) return;
            minigameData.angle += (minigameData.speed || 0.015);
        }

        function drawOrbiting() {
            if (!minigameData || !minigameData.planet) return;
            clear();
            updateStars(farStars); updateStars(midStars); updateStars(stars);
            drawStars(farStars); drawStars(midStars);
            const planet = minigameData.planet;
            drawPlanets();
            const orbitRadius = minigameData.orbits[minigameData.currentOrbit];
            player.x = planet.x + Math.cos(minigameData.angle) * orbitRadius - player.width / 2;
            player.y = planet.y + Math.sin(minigameData.angle) * orbitRadius - player.height / 2;
            ctx.strokeStyle = "rgba(255, 255, 255, 0.2)"; ctx.lineWidth = 1;
            minigameData.orbits.forEach(r => { ctx.beginPath(); ctx.arc(planet.x, planet.y, r, 0, Math.PI * 2); ctx.stroke(); });
            let targetAngle = minigameData.isTargetPlanet ? Math.PI : 0;
            const isFinalOrbit = minigameData.currentOrbit === minigameData.orbits.length - 1;
            if(minigameData.isTargetPlanet && !isFinalOrbit) { targetAngle = Math.PI; }
            ctx.strokeStyle = "#f6e05e"; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.arc(planet.x, planet.y, orbitRadius, targetAngle - minigameData.escapeWindow / 2, targetAngle + minigameData.escapeWindow / 2); ctx.stroke();
            ctx.fillStyle = "white"; ctx.font = "16px Bangers";
            ctx.fillText("APOGEE", planet.x - orbitRadius - 40, planet.y + 25);
            ctx.fillText("PERIGEE", planet.x + orbitRadius - 20, planet.y + 25);
            drawPlayer(); drawStars(stars);
        }

        function handleMinigameAction() {
            try {
                if (!minigameData.planet) return;
                let targetAngle = minigameData.isTargetPlanet ? Math.PI : 0;
                const isFinalOrbit = minigameData.currentOrbit === minigameData.orbits.length - 1;
                if (minigameData.isTargetPlanet && !isFinalOrbit) { targetAngle = Math.PI; }
                let currentAngle = (minigameData.angle % (Math.PI * 2) + (Math.PI * 2)) % (Math.PI * 2);
                const window = minigameData.escapeWindow;
                const lowerBound = (targetAngle - window / 2 + (Math.PI * 2)) % (Math.PI * 2);
                const upperBound = (targetAngle + window / 2 + (Math.PI * 2)) % (Math.PI * 2);
                let inWindow = lowerBound > upperBound ? (currentAngle >= lowerBound || currentAngle <= upperBound) : (currentAngle >= lowerBound && currentAngle <= upperBound);
                
                if (inWindow) {
                    if (synths.shot) synths.shot.triggerAttackRelease("G4", "8n");
                    if (minigameData.isTargetPlanet) {
                        if (isFinalOrbit) { missionAccomplished(); } 
                        else { 
                            minigameData.currentOrbit++; 
                            if(minigameData.currentOrbit === minigameData.orbits.length -1) {
                                minigamePrompt.textContent = "FINAL MANEUVER: TAP [SPACE] AT APOGEE!";
                            }
                        }
                    } else { escapeOrbit(); }
                } else { endGame("You missed the gravity-well timing and crashed!"); }
            } catch(e) { console.error("Error in orbit game:", e); escapeOrbit(); }
        }
        
        function escapeOrbit() {
            showPopup("Slingshot successful!", false);
            distance += 2500;
            player.fuel = Math.min(player.maxFuel, player.fuel + 25);
            minigamePrompt.classList.add('hidden');
            if(minigameData && minigameData.planet) {
                lastVisitedPlanet = minigameData.planet.name;
                planets = planets.filter(p => p !== minigameData.planet);
            }
            minigameData = {};
            player.x = 100; player.y = canvas.height / 2 - player.height / 2; player.vy = 0;
            setGameState(GameState.FLYING);
            setupMissionPath();
        }
        
        // --- Mini-Game: Constellation ---
        function triggerConstellationGame() {
            setGameState(GameState.CONSTELLATION_MINIGAME);
            const names = Object.keys(CONSTELLATIONS);
            const name = names[Math.floor(Math.random() * names.length)];
            const data = CONSTELLATIONS[name];
            const margin = 150;
            const drawWidth = canvas.width - (margin * 2);
            const drawHeight = canvas.height - (margin * 2);
            constellationGame = {
                name: name,
                stars: data.stars.map(s => ({ x: s.x * drawWidth + margin, y: s.y * drawHeight + margin, radius: 10 })),
                lines: data.lines,
                completedLines: [], selectedStar: null, isAnimating: false,
                animationProgress: 0, animationStart: null, animationEnd: null, timer: 2400
            };
            const timeRemaining = Math.ceil(constellationGame.timer / 60);
            constellationPrompt.innerHTML = `Trace the constellation: <strong>${name}</strong><br>Time Left: ${timeRemaining}s`;
            constellationPrompt.classList.remove('hidden');
        }

        function updateConstellationGame() {
            try {
                if (!constellationGame.name) return;
                constellationGame.timer--;
                const timeRemaining = Math.ceil(constellationGame.timer / 60);
                constellationPrompt.innerHTML = `Trace the constellation: <strong>${constellationGame.name}</strong><br>Time Left: ${timeRemaining}s`;

                if (constellationGame.timer <= 0) {
                    endConstellationGame(false);
                } else if (constellationGame.isAnimating) {
                    constellationGame.animationProgress += 0.05;
                    if (constellationGame.animationProgress >= 1) {
                        constellationGame.isAnimating = false;
                        constellationGame.animationProgress = 0;
                        if (constellationGame.completedLines.length === constellationGame.lines.length) {
                            endConstellationGame(true);
                        }
                    }
                }
            } catch(e) { console.error("Error in constellation game:", e); endConstellationGame(false); }
        }

        function drawConstellationGame() {
            clear();
            drawStars(farStars); drawStars(midStars); drawStars(stars);
            const game = constellationGame;
            if(!game.stars) return;

            ctx.strokeStyle = "rgba(100, 200, 255, 0.2)"; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
            game.lines.forEach(line => {
                const start = game.stars[line.from];
                const end = game.stars[line.to];
                ctx.beginPath(); ctx.moveTo(start.x, start.y); ctx.lineTo(end.x, end.y); ctx.stroke();
            });
            ctx.setLineDash([]);

            ctx.strokeStyle = "#f6e05e"; ctx.lineWidth = 4;
            game.completedLines.forEach(line => {
                const start = game.stars[line.from];
                const end = game.stars[line.to];
                ctx.beginPath(); ctx.moveTo(start.x, start.y); ctx.lineTo(end.x, end.y); ctx.stroke();
            });

            if (game.isAnimating) {
                ctx.strokeStyle = "#ffffff"; ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(game.animationStart.x, game.animationStart.y);
                ctx.lineTo(lerp(game.animationStart.x, game.animationEnd.x, game.animationProgress), lerp(game.animationStart.y, game.animationEnd.y, game.animationProgress));
                ctx.stroke();
            }

            game.stars.forEach((star, index) => {
                ctx.fillStyle = game.selectedStar === index ? "#ffffff" : "#a0deff";
                ctx.beginPath(); ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2); ctx.fill();
            });
        }
        
        function endConstellationGame(success) {
            constellationPrompt.classList.add('hidden');
            if (success) {
                showPopup("Constellation Charted! +50 Fuel!", false);
                player.fuel = Math.min(player.maxFuel, player.fuel + 50);
                if(synths.victory) synths.victory.triggerAttackRelease("A5", "1n");
            } else {
                showPopup("Lost in the stars...", true);
            }
            constellationGame = {};
            setGameState(GameState.FLYING);
        }
        
        // --- Mini-Game: Wormhole ---
        function triggerIntergalacticWormhole(destinationIndex) {
            showPopup("Intergalactic Wormhole Detected!", true);
            setTimeout(() => {
                setGameState(GameState.WORMHOLE_MINIGAME);
                minigamePrompt.textContent = "Stabilize The Vortex!";
                minigamePrompt.classList.remove('hidden');
                let level = 3;
                if (lastDifficulty === 'easy') level = 2;
                if (lastDifficulty === 'hard') level = 4;
                wormholeGame = {
                    sequence: [], playerSequence: [], level: level, state: 'STARTING',
                    showTimer: 0, currentIndex: 0, flashCorrect: -1, flashIncorrect: false,
                    destinationIndex: destinationIndex
                };
                for (let i = 0; i < wormholeGame.level; i++) { wormholeGame.sequence.push(Math.floor(Math.random() * 4)); }
                wormholeGame.state = 'SHOWING';
            }, 2000);
        }

        function updateWormholeGame() {
            const game = wormholeGame;
            if (game.state === 'SHOWING') {
                game.showTimer = (game.showTimer || 0) + 1;
                if (game.showTimer > 60) {
                    game.showTimer = 0;
                    game.currentIndex++;
                    if (game.currentIndex >= game.sequence.length) {
                        game.state = 'PLAYER_TURN';
                        game.currentIndex = 0;
                        minigamePrompt.textContent = "Your Turn! (Keys 1-4)";
                    }
                }
            }
        }

        function drawWormholeGame() {
            clear();
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(wormholeGame.rotation || 0);
            wormholeGame.rotation = (wormholeGame.rotation || 0) + 0.01;
            const gradient = ctx.createRadialGradient(0, 0, 50, 0, 0, 300);
            gradient.addColorStop(0, '#000');
            gradient.addColorStop(0.5, '#4a00e0');
            gradient.addColorStop(1, '#8e2de2');
            ctx.fillStyle = gradient;
            ctx.fillRect(-canvas.width, -canvas.height, canvas.width * 2, canvas.height * 2);
            ctx.restore();

            const colors = ['#f56565', '#48bb78', '#f6e05e', '#63b3ed'];
            const positions = [{x: -100, y: -50}, {x: 100, y: -50}, {x: -100, y: 50}, {x: 100, y: 50}];
            const game = wormholeGame;

            positions.forEach((pos, i) => {
                ctx.fillStyle = colors[i];
                ctx.globalAlpha = 0.6;
                if (game.state === 'SHOWING' && game.sequence[game.currentIndex] === i && game.showTimer < 50) {
                    ctx.globalAlpha = 1;
                }
                if (game.flashCorrect === i) {
                    ctx.globalAlpha = 1;
                }
                if (game.flashIncorrect && game.playerSequence[game.currentIndex] === i) {
                    ctx.fillStyle = "white";
                    ctx.globalAlpha = 1;
                }
                ctx.fillRect(centerX + pos.x - 40, centerY + pos.y - 40, 80, 80);
                
                ctx.fillStyle = "white";
                ctx.font = "40px Bangers";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.globalAlpha = 1;
                ctx.fillText(i + 1, centerX + pos.x, centerY + pos.y);
            });

            if (game.flashCorrect > -1 || game.flashIncorrect) {
                game.flashTimer = (game.flashTimer || 0) + 1;
                if (game.flashTimer > 15) {
                    game.flashTimer = 0;
                    game.flashCorrect = -1;
                    game.flashIncorrect = false;
                }
            }
        }

        function handleWormholeInput(keyIndex) {
            const game = wormholeGame;
            if (!game.state || game.state !== 'PLAYER_TURN') return;

            game.playerSequence.push(keyIndex);
            
            if (game.sequence[game.currentIndex] === keyIndex) {
                game.flashCorrect = keyIndex;
                if (synths.collect) synths.collect.triggerAttackRelease(`${['C5', 'E5', 'G5', 'A5'][keyIndex]}`, "16n");
                game.currentIndex++;

                if (game.currentIndex >= game.sequence.length) {
                    // Success
                    wormholeGame = {};
                    setGameState(GameState.FLYING);
                    minigamePrompt.classList.add('hidden');
                    if (game.destinationIndex !== undefined) {
                        showPopup(`Entering ${GALAXY_ORDER[game.destinationIndex].name}!`, false);
                        currentGalaxyIndex = game.destinationIndex;
                        missionQueue = [...GALAXY_ORDER[currentGalaxyIndex].planets].sort(() => 0.5 - Math.random());
                        startNextMissionLeg();
                    } else if(game.destination === 'skip') {
                        showPopup("Quantum Tunnel Successful!", false);
                        distance += 5000;
                        if(missionQueue.length > 0) startNextMissionLeg();
                    }
                }
            } else {
                // Failure
                game.flashIncorrect = true;
                if (synths.crash) synths.crash.triggerAttackRelease("C2", "8n");
                showPopup("Wormhole Collapsed!", true);
                player.fuel = Math.max(0, player.fuel - 20);
                wormholeGame = {};
                setGameState(GameState.FLYING);
                minigamePrompt.classList.add('hidden');
            }
        }

        // --- Mini-Game: Timing ---
        function triggerTimingGame() {
            setGameState(GameState.TIMING_MINIGAME);
            timingGame = {
                radius: 200, targetRadius: 50, shrinkRate: 1,
                successWindow: gameDifficultySettings.timingWindow, state: 'shrinking'
            };
            minigamePrompt.textContent = "Press [SPACE] in the Target Zone!";
            minigamePrompt.classList.remove('hidden');
        }

        function updateTimingGame() {
            if (timingGame.state === 'shrinking') {
                timingGame.radius -= timingGame.shrinkRate;
                if (timingGame.radius < timingGame.targetRadius - timingGame.successWindow) {
                    timingGame.state = 'done';
                    showPopup("Missed!", true);
                    player.fuel = Math.max(0, player.fuel - 15);
                    minigamePrompt.classList.add('hidden');
                    timingGame = {};
                    setGameState(GameState.FLYING);
                }
            }
        }

        function drawTimingGame() {
            if (timingGame.state !== 'shrinking') return;
            clear();
            drawStars(farStars); drawStars(midStars); drawStars(stars);
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.strokeStyle = '#f6e05e'; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.arc(centerX, centerY, timingGame.targetRadius, 0, Math.PI * 2); ctx.stroke();

            ctx.strokeStyle = '#63b3ed'; ctx.lineWidth = 6;
            ctx.beginPath(); ctx.arc(centerX, centerY, timingGame.radius, 0, Math.PI * 2); ctx.stroke();
            
            drawPlayer();
        }

        function handleTimingAction() {
            if (timingGame.state !== 'shrinking') return;
            const diff = Math.abs(timingGame.radius - timingGame.targetRadius);
            if (diff <= timingGame.successWindow) {
                showPopup("Perfect! +20 Fuel", false);
                player.fuel = Math.min(player.maxFuel, player.fuel + 20);
            } else {
                showPopup("Missed!", true);
                player.fuel = Math.max(0, player.fuel - 15);
            }
            timingGame.state = 'done';
            minigamePrompt.classList.add('hidden');
            timingGame = {};
            setGameState(GameState.FLYING);
        }

        // --- Game Flow & State Management ---
        function missionAccomplished() {
            setGameState(GameState.MISSION_BRIEF);
            player.visible = false;
            minigamePrompt.classList.add('hidden');
            stopMusic();
            if(synths.victory) synths.victory.triggerAttackRelease("G5", "1n");
            
            lastVisitedPlanet = targetPlanetName;
            minigameData = {}; // Clear minigame data
            document.getElementById('mission-title').textContent = `You've reached ${targetPlanetName}!`;

            if (missionQueue.length === 0 && currentGalaxyIndex >= GALAXY_ORDER.length - 1) {
                document.getElementById('mission-text').textContent = "All planets visited! Your final mission awaits.";
                continueButton.textContent = "Begin Final Escape";
            } else if (missionQueue.length === 0) {
                document.getElementById('mission-text').textContent = `Exploration of ${GALAXY_ORDER[currentGalaxyIndex].name} complete! A wormhole to a new galaxy awaits.`;
                continueButton.textContent = "Travel to Next Galaxy";
            } else {
                document.getElementById('mission-text').textContent = "Rendezvous successful! Prepare for your next assignment.";
                continueButton.textContent = "Continue Voyage";
            }
            missionScreen.classList.remove('hidden');
        }

        function finalEscapeMission() {
            setGameState(GameState.HYPERDRIVE_ESCAPE);
            missionScreen.classList.add('hidden');
            resetForNextLeg();
            player.fuel = player.maxFuel;
            targetDisplay.textContent = "TARGET: ESCAPE THE GALAXY";
            hyperdrive.charge = 0;
            hyperdrive.active = true;
            hyperdriveContainer.classList.remove('hidden');
            startMusic();
            showPopup("FINAL OBJECTIVE: CHARGE THE HYPERDRIVE!", true);
            if(!animationFrameId) gameLoop();
        }

        function finalVictory() {
            setGameState(GameState.GAMEOVER);
            stopMusic();
            if (synths.victory) synths.victory.triggerAttackRelease(["C5", "E5", "G5", "C6"], "1n");
            let highScore = localStorage.getItem('cosmicVoyagerHighScore') || 0;
            if (distance > highScore) { highScore = distance; localStorage.setItem('cosmicVoyagerHighScore', highScore); }
            
            gameOverScreen.classList.remove('hidden');
            missionScreen.classList.add('hidden');
            hyperdriveContainer.classList.add('hidden');
            minigamePrompt.classList.add('hidden');

            gameOverTitle.textContent = "GALAXY ESCAPED!";
            finalDistanceDisplay.textContent = `You left the known universe behind and traveled ${Math.floor(distance)} km!`;
            gameOverHighScoreDisplay.textContent = `High Score: ${Math.floor(highScore)} km`;
        }
        
        function endGame(reason) {
            if (gameState === GameState.GAMEOVER) return;
            setGameState(GameState.GAMEOVER);
            stopMusic();
            if (eventState.flickerInterval) clearInterval(eventState.flickerInterval);

            let highScore = localStorage.getItem('cosmicVoyagerHighScore') || 0;
            if (distance > highScore) { highScore = distance; localStorage.setItem('cosmicVoyagerHighScore', highScore); }

            gameOverScreen.classList.remove('hidden');
            constellationPrompt.classList.add('hidden');
            minigamePrompt.classList.add('hidden');
            hyperdriveContainer.classList.add('hidden');
            gameOverTitle.textContent = "Mission Failed!";
            finalDistanceDisplay.textContent = `You traveled ${Math.floor(distance)} km. ${reason}`;
            gameOverHighScoreDisplay.textContent = `High Score: ${Math.floor(highScore)} km`;
        }

        function initGame() {
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            setGameState(GameState.MENU);
            stopMusic();
            let highScore = localStorage.getItem('cosmicVoyagerHighScore') || 0;
            highScoreDisplay.textContent = `High Score: ${Math.floor(highScore)} km`;
            startScreen.classList.remove('hidden');
            gameOverScreen.classList.add('hidden');
            missionScreen.classList.add('hidden');
            minigamePrompt.classList.add('hidden');
            minigamePrompt.textContent = "";
            hyperdriveContainer.classList.add('hidden');
            init();
        }

        function lerp(a, b, t) { return a * (1 - t) + b * t; }
        
        function triggerEvent(type, duration) {
            if (type === 'WORMHOLE') {
                return setTimeout(() => {
                    setGameState(GameState.WORMHOLE_MINIGAME);
                    minigamePrompt.textContent = "Stabilize The Vortex!";
                    minigamePrompt.classList.remove('hidden');
                    let level = 3;
                    if (lastDifficulty === 'easy') level = 2;
                    if (lastDifficulty === 'hard') level = 4;
                    wormholeGame = {
                        sequence: [], playerSequence: [], level: level, state: 'STARTING', showTimer: 0,
                        currentIndex: 0, flashCorrect: -1, flashIncorrect: false, destination: duration
                    };
                    for (let i = 0; i < wormholeGame.level; i++) { wormholeGame.sequence.push(Math.floor(Math.random() * 4)); }
                    wormholeGame.state = 'SHOWING';
                }, 1000);
            }
            eventState = { active: true, type, duration, gracePeriod: 0 };
            if (type === 'BLACK_HOLE') {
                showPopup("GRAVITATIONAL ANOMALY! ESCAPE!", true);
                eventState.hole = { x: 50, y: canvas.height / 2, radius: 150 };
                eventState.gracePeriod = 60;
                sceneryObjects.push({ x: canvas.width + 250, y: canvas.height / 2, speed: 5, size: 50, emoji: 'üõ∞Ô∏è', rotation: -0.5 });
            }
            if (type === 'NEBULA' || type === 'ASTEROID_BELT') {
                showPopup(`ENTERING ${type.replace("_", " ")}!`, type === 'ASTEROID_BELT');
                 if(type === 'NEBULA') {
                    nebulaParticles = [];
                    Array.from({length: 50}).forEach(() => {
                        nebulaParticles.push({
                            x: Math.random() * canvas.width * 1.5, y: Math.random() * canvas.height,
                            radius: Math.random() * 80 + 80, speed: Math.random() * 0.1 + 0.1,
                            color: `rgba(${Math.random()*50 + 100}, ${Math.random()*50}, ${Math.random()*100 + 155}, ${Math.random()*0.1 + 0.05})`
                        });
                    });
                }
                eventState.flickerInterval = setInterval(() => {
                    const elements = [distanceDisplay, empDisplay, fuelContainer];
                    const el = elements[Math.floor(Math.random() * elements.length)];
                    el.classList.add('flicker');
                    setTimeout(() => el.classList.remove('flicker'), 400);
                }, 2000);
            }
        }

        function showPopup(message, isAlert) {
            popupText.textContent = message;
            popupText.className = isAlert ? "popup-text alert-text" : "popup-text";
            popupContainer.classList.remove('hidden');
            setTimeout(() => popupContainer.classList.add('hidden'), 3000);
        }

        // --- Audio Setup ---
        function setupAudioSynths() {
            if (synths.crash) return;
            synths.crash = new Tone.MetalSynth({ frequency: 50, envelope: { attack: 0.001, decay: 1.4, release: 0.2 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination();
            synths.shot = new Tone.FMSynth({ harmonicity: 1.2, modulationIndex: 10, envelope: { attack: 0.01, decay: 0.5, release: 0.2 }, modulationEnvelope: { attack: 0.01, decay: 0.3, release: 0.2 } }).toDestination();
            synths.victory = new Tone.PolySynth(Tone.Synth).toDestination();
            synths.collect = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 } }).toDestination();
            synths.emp = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination();
            synths.emp.volume.value = -18;
            synths.bgm = new Tone.FMSynth({ harmonicity: 0.5, modulationIndex: 1.2, envelope: { attack: 0.1, decay: 0.5, release: 1 }, modulationEnvelope: { attack: 0.05, decay: 0.2, release: 0.8 } }).toDestination();
            synths.bgm.volume.value = -25;
            const melody = ["C2", "Eb2", "G2", "C3", "G2", "Eb2"];
            synths.bgm_sequence = new Tone.Sequence((time, note) => { if (synths.bgm) synths.bgm.triggerAttackRelease(note, "8n", time); }, melody, "4n");
            Tone.Transport.bpm.value = 90;
        }
        function startMusic() { if (Tone.Transport.state !== 'started') { synths.bgm_sequence.start(0); Tone.Transport.start(); } }
        function stopMusic() { if (Tone.Transport.state === 'started') { Tone.Transport.stop(); synths.bgm_sequence.stop(0); } }

        function preloadImages(sources) {
            return new Promise(resolve => {
                let loaded = 0;
                const numImages = Object.keys(sources).length;
                if (numImages === 0) return resolve();
                for (const key in sources) {
                    planetImages[key] = new Image();
                    planetImages[key].crossOrigin = "Anonymous";
                    planetImages[key].onload = planetImages[key].onerror = () => { if (++loaded >= numImages) { resolve(); } };
                    planetImages[key].src = sources[key];
                }
            });
        }
        
        // --- Event Listeners ---
        document.addEventListener('keydown', e => {
            if (e.repeat) return;
            if (e.code === 'Space') {
                if ((gameState === GameState.ORBITING && handleMinigameAction()) ||
                    (gameState === GameState.TIMING_MINIGAME && handleTimingAction()) ||
                    (gameState === GameState.HYPERDRIVE_ESCAPE && hyperdrive.charge >= hyperdrive.maxCharge && finalVictory())) {
                    e.preventDefault();
                }
                keys.space = true;
            } else if (gameState === GameState.WORMHOLE_MINIGAME && e.key >= '1' && e.key <= '4') {
                e.preventDefault();
                handleWormholeInput(parseInt(e.key) - 1);
            } else if (e.key === 'e' || e.key === 'E') {
                e.preventDefault(); triggerEMP();
            } else if (e.key === 'q' || e.key === 'Q') {
                e.preventDefault(); keys.q = true;
                if (gameState === GameState.EVENT && eventState.type === 'BLACK_HOLE' && synths.shot) {
                    synths.shot.triggerAttackRelease("C3", "16n");
                }
            } else if (e.key === 'ArrowUp') keys.up = true;
            else if (e.key === 'ArrowDown') keys.down = true;
            else if (e.key === 'Shift') keys.shift = true;
            else if (e.key === 's' || e.key === 'S') keys.shield = true;
        });
        document.addEventListener('keyup', e => {
            if (e.code === 'Space') keys.space = false;
            else if (e.key === 'q' || e.key === 'Q') keys.q = false;
            else if (e.key === 'ArrowUp') keys.up = false;
            else if (e.key === 'ArrowDown') keys.down = false;
            else if (e.key === 'Shift') keys.shift = false;
            else if (e.key === 's' || e.key === 'S') keys.shield = false;
        });

        // Mobile Controls
        upButton.addEventListener('mousedown', () => keys.up = true);
        downButton.addEventListener('mousedown', () => keys.down = true);
        shieldButton.addEventListener('mousedown', () => keys.shield = true);
        upButton.addEventListener('touchstart', e => { e.preventDefault(); keys.up = true; });
        downButton.addEventListener('touchstart', e => { e.preventDefault(); keys.down = true; });
        shieldButton.addEventListener('touchstart', e => { e.preventDefault(); keys.shield = true; });
        document.addEventListener('mouseup', () => { keys.up = false; keys.down = false; keys.shield = false; });
        document.addEventListener('touchend', () => { keys.up = false; keys.down = false; keys.shield = false; });

        // Constellation Interaction
        function handleInteractionStart(e) {
            e.preventDefault();
            if (gameState !== GameState.CONSTELLATION_MINIGAME || !constellationGame.stars || constellationGame.isAnimating) return;
            const { x, y } = getCanvasCoords(e);
            const clickedStarIndex = constellationGame.stars.findIndex(star => Math.hypot(x - star.x, y - star.y) < star.radius * 2);
            if (clickedStarIndex !== -1) { constellationGame.selectedStar = clickedStarIndex; }
        }
        function handleInteractionEnd(e) {
            e.preventDefault();
            if (gameState !== GameState.CONSTELLATION_MINIGAME || !constellationGame.stars || constellationGame.selectedStar === null || constellationGame.isAnimating) return;
            
            const { x, y } = getCanvasCoords(e);
            if (x === null) { // Handle case where touch ends outside canvas
                constellationGame.selectedStar = null;
                return;
            }
            
            const releasedStarIndex = constellationGame.stars.findIndex(star => Math.hypot(x - star.x, y - star.y) < star.radius * 2);

            if (releasedStarIndex !== -1 && releasedStarIndex !== constellationGame.selectedStar) {
                const startIdx = constellationGame.selectedStar;
                const endIdx = releasedStarIndex;
                
                // *** FIX STARTS HERE ***
                // Find a line in the master list that matches the user's drawn line and is not already completed.
                const lineToComplete = constellationGame.lines.find(line => {
                    const matchesDrawnLine = (line.from === startIdx && line.to === endIdx) || (line.from === endIdx && line.to === startIdx);
                    if (!matchesDrawnLine) {
                        return false;
                    }
                    const isAlreadyCompleted = constellationGame.completedLines.some(completed =>
                        (completed.from === line.from && completed.to === line.to) || (completed.from === line.to && completed.to === line.from)
                    );
                    return !isAlreadyCompleted;
                });
                // *** FIX ENDS HERE ***

                if (lineToComplete) {
                    constellationGame.completedLines.push(lineToComplete);
                    constellationGame.isAnimating = true;
                    constellationGame.animationStart = constellationGame.stars[startIdx];
                    constellationGame.animationEnd = constellationGame.stars[endIdx];
                    constellationGame.animationProgress = 0;
                    if(synths.shot) synths.shot.triggerAttackRelease("C5", "8n");
                }
            }
            constellationGame.selectedStar = null;
        }
        function getCanvasCoords(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.type.startsWith('touch')) {
                const touch = e.changedTouches ? e.changedTouches[0] : (e.touches ? e.touches[0] : null);
                if(touch) { clientX = touch.clientX; clientY = touch.clientY; }
                else { clientX = null; clientY = null; }
            } else { clientX = e.clientX; clientY = e.clientY; }
            return { x: clientX - rect.left, y: clientY - rect.top };
        }
        canvas.addEventListener('mousedown', handleInteractionStart);
        canvas.addEventListener('mouseup', handleInteractionEnd);
        canvas.addEventListener('touchstart', handleInteractionStart, { passive: false });
        canvas.addEventListener('touchend', handleInteractionEnd);
        
        // Button Listeners
        document.querySelectorAll('.difficulty-btn').forEach(button => {
            button.addEventListener('click', async () => {
                if(!isAudioContextStarted){ await Tone.start(); isAudioContextStarted = true; setupAudioSynths(); }
                startGame(button.dataset.difficulty);
            });
        });
        restartButton.addEventListener('click', () => startGame(lastDifficulty));
        exitButton.addEventListener('click', initGame);
        continueButton.addEventListener('click', () => {
            missionScreen.classList.add('hidden');
            if (continueButton.textContent === "Begin Final Escape") {
                finalEscapeMission();
            } else {
                startMusic();
                startNextMissionLeg();
            }
        });

        // Window Load/Resize
        window.onload = async () => {
            resizeCanvas();
            const difficultySelector = document.getElementById('difficulty-selection');
            difficultySelector.style.display = 'none';
            highScoreDisplay.textContent = "Loading cosmic assets...";
            await preloadImages(imageSources);
            difficultySelector.style.display = 'flex';
            initGame();
        };
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
                
